Isotropic nonlinear texture effects for letterforms from a scale-space representation
=====================================================================================

I was walking by some of those goofy hipster chalkboard signs in my
*cheto* neighborhood today and noticed that a lot of them are produced
from a bunch of relatively simple transformations of letterforms:
outlining, drop-shadowing, color gradients, and so on.  It occurred to
me that it’s probably feasible to mechanically explore restricted but
visually interesting sets of such transformations in the form of DAGs
of a simple algebra.

In many cases, it would be ideal for the transformation to be
shift-invariant (s-i), rotation-invariant (i), resolution-invariant
(r-i), and bounded-amplitude (b) — that is, transforming a shifted,
rotated, or resampled image should produce the shifted, rotated, or
resampled transformation of the original image, and that it should be
possible to compute bounds on the brightness of the pixels in the
transformed image, at least given bounds on the brightness of the
images in the original image.  Moreover, if you want to do image
approximation for style transfer (see file `image-approximation`) it
might be helpful for the transformation to be differentiable with
respect to some set of parameters.  These restrictions reduce the
space of possible transformations in a way that should dramatically
accelerate stochastic exploration and mathematical optimization.

Note that it is quite explicitly *not* a goal to restrict ourselves to
*linear* transformations.

This is quite similar to, and inspired by, the abundance of excellent
work in recent years on computer vision using neural networks.

(See also file `texture-algebra` and file `cheap-textures`.)

The basics: isotropic scale-space representation
------------------------------------------------

Given a sampled image, you can convolve it with some linear filter to
get a transformed image; this transformation is shift-invariant (s-i)
from the definition of convolution.  If the filter’s impulse response
is isotropic, which is to say rotation-invariant (i), this
transformation will be isotropic.  If the linear filter *fₛ* has a
scale parameter *s* such that *fₖₛ* gives the same linear filter
resampled to a new sampling grid *k* times larger, then you can
satisfy the resolution-invariance criterion.  You can derive
reasonable amplitude bounds on the resulting image from amplitude
bounds on the original image and on the filter’s impulse response.

A particularly appealing filter is the Gaussian, the scaled function
exp(-*r*²), both because it’s the only isotropic separable filter and
because it can be very inexpensively approximated using CIC or
Hogenauer filters, called repeated box blurs in image
processing — independent of the radius, a quadratic approximation to
the Gaussian (up to a constant scale factor) takes only six
subtractions per pixel, given a dimension-indepenent third-order
two-dimensional prefix sum (aka summed-area table) of the image, which
requires six additions per pixel to compute, and in general about four
times as much space as the origial image.

(An additional desirable property is that Gaussian convolution is
closed under composition: the composition of two Gaussian convolutions
is a third Gaussian convolution whose scale parameter is simply the
sum of the scale parameters of the two.)

This is the standard [scale-space representation][0] used in machine
vision since the 1960s, the two-dimensional analogue of the
one-dimensional [Weierstrass transform][1] used in analysis (and in
particular function approximation) since the 1800s.

[0]: https://en.wikipedia.org/wiki/Scale_space
[1]: https://en.wikipedia.org/wiki/Weierstrass_transform

So you can use Gaussian convolutions with arbitrary constant radii as
elementary operations in your algebra of transformations without risk
of producing an inefficient, anisotropic (¬i), shift-variant (¬s-i),
resolution-dependent (¬r-i), or unbounded (¬b) transformation.
Moreover the transformation is differentiable with respect to both the
input image and the scale parameter.

Another class of scalable isotropic filters that admit especially
efficient implementations of convolution are flat† circles — circular
boxcar filters.  These are less efficient than Gaussian convolution,
especially as kernel sizes grow, but, as discussed in file
`convolution-bokeh`, they still admit much more efficient
implementations than are generally known in the literature, on the
order of 1–3 additions and subtractions per scan line in the kernel,
or less if polygonal approximations are used.

Flat circle convolution is i and r-i except for aliasing artifacts, b,
and s-i.  It’s differentiable with respect to the input image, but
it’s imperfectly differentiable with respect to the scale parameter;
the flatness constraint requires the circle to expand by discrete
pixels, which create discontinuities in its derivative.  I feel like
you should be able to make a differentiable version by lerping between
circles of adjacent radii; using the above-linked algorithms, such a
filter can be implemented at much less than twice the cost of a single
flat circle convolution, since the two circles will be equal on most
scan lines.

† “Flat” in the sense that all points within the support of the filter
have the same “height”.

Nonlinear morphological operators
---------------------------------

Another class of shift-invariant, resolution-invariant, and
bounded-amplitude transformations on images with efficient
interpretations are the nonlinear morphological operations of erosion
⊖ and dilation ⊕; if used with an isotropic “structuring element” or
kernel, such as a flat circle, these operations are isotropic.  These,
too, have been used in machine vision since the 1970s.  As described
in file `bresenham-erosion`, Urbach and Wilkinson published an
algorithm that can evaluate these operators with flat kernels at only
slightly higher computational cost than the linear convolution with
flat circular kernels described in the previous section, and it's
straightforward to shave off another factor of 2 or 3 from Urbach and
Wilkinson’s algorithm in most cases.

So you can use erosion and dilation with flat circles with arbitrary
constant radii as additional elementary operations; as with the
isotropic convolution cases, this poses no risk of producing an
inefficient, anisotropic, shift-variant, scale-variant, or unbounded
transformation.

Combining operators
-------------------

### Arithmetic pixelwise combination ###

Given constant images and the above elementary unary operations on
images, we can combine them pixelwise using most of the standard
mathematical operators: +, -, ×, ∧ (minimum), ∨ (maximum), and in some
cases ÷, if appropriate bounds can be shown to hold for the input
images.  (But not %.)  In particular, note that ×, ∧, and ∨ permit the
realization of nonlinear image filtering operations even without the
use of any non-pixelwise nonlinear operations such as the
morphological operations.

Moreover, you can apply a number of unary operations pixelwise, such
as exp, sin, cos, atan, and in some cases ln.

### Bounds-preserving operators ###

However, I think the above set of combining operators is somewhat
suboptimal with respect to its boundedness and efficiency.  It’s true
that you can compute bounds on *a* + *b* or *a* × *b* given bounds on
*a* and *b*, but if you’re randomly assembling DAGs in this algebra, a
lot of them will randomly have very large or very small bounds.  It
would be desirable to have a similarly expressive set of operations in
which, if both inputs are bounded to some range, the output is too.

In particular, consider the case of *a*, *b*, *c* ∈ [0, 1].  Then
these combining operations preserve that bound:

- ½*a* + ½*b*
- ½*a* - ½*b* + ½
- *a* × *b*
- *a* ∨ *b*
- *a* ∧ *b*
- *a* + *b* × (*c* - *a*) (lerp)
- lg (1 + *a*)
- 2<sup>*a*</sup> - 1
- ½sin(*ωa* + *φ*) + ½
- *a*/(*a* + *b*)
- 1 - *a*

Dynamical systems
-----------------

- state machines
- differential equations and Runge–Kutta

Anisotropy
----------

- shifts
- calligraphy pens
- penalty functions
