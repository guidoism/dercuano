I was thinking about the famous Martin Shkreli screencast with Excel
where he spends a few minutes working up a basic analysis of a
company’s balance sheet.  Although in a sense what he’s doing is
mostly very simple, the demo is very flashy, and I certainly wouldn’t
be able to do it as quickly.  He ends up spending an unreasonable
amount of time cutting and pasting individual numbers from his browser
into Excel.

Then I thought about the kids at my high school who played half an
hour of Tetris per day (between classes) during a school year, which
worked out to about 90 hours of Tetris practice spaced over most of a
year.  They reached fairly impressive speeds at Tetris, though one day
I was wandering around Kobe and wandered into a video arcade where I
saw some random Japanese dude doing Tetris things I had never imagined
a human could do.  He probably had thousands of hours of Tetris
practice spaced over several years.

Typing games can rapidly improve typing speed once you’ve learned the
basic touch-typing technique, while day-to-day typing, lacking the
same time pressure, usually won’t.

Programming often involves a lot of fiddling with user interfaces that
don’t offer a very direct way to get the result you’re looking for, or
determine whether you’ve gotten it, even for things that conceptually
aren’t very complicated.  Some aspects of programming naturally
involve deep thought, but others just involve rapid trial and error,
and the higher the frequency at which this can be done, the better.

I wonder if you could hack together some kind of IDE that would enable
interaction at a video-game pace, with video-game-like smoothness, and
a series of exercises that would provide you with incentives to learn
to use it smoothly, the way video games first guide you through a
tutorial to learn their user interfaces and then use the gameplay to
bring you gradually to a near-superhuman level of performance with
them.  Perhaps it could provide you with responsive interaction
options you could use to incrementally approximate the program you
wanted, getting rich, instant, and varied feedback on the program you
had gotten so far and what the next possible steps would look like.

Some example mechanics:

* Extrinsically-organized prizes to guide you.

* Programming by example, as in Excel, gives you the opportunity to
  see an example output from your algorithm as you are developing it
  step by step.  In some cases, it would be useful to see several
  outputs from different runs in parallel.

* Whether or not you’re programming by example, it’s useful to
  visualize the inputs, outputs, and intermediate values of any
  algorithm, whether these be test inputs or real inputs.  But
  different kinds of data might have different kinds of
  visualizations.  As in Excel, scalar numbers can be visualized as
  numbers; univariate functions could be visualized as plots or
  perhaps played as sounds; bivariate functions could be visualized as
  images, 3-D plots, scatterplots, face plots, series of slices, and
  so on; tabular data can be displayed in tables; strings can be
  rendered as sequences of glyphs; and so on.  Bret Victor’s work
  visualizing Nile offers inspiration here.

* When programming by example, in general, you have some values and
  some operations on them that can yield further values.  If you’re
  focusing on one or two values in particular, there’s some set of
  operations you’re likely to apply to them to get more values.  For
  example, if your value is a set of angles, likely operations might
  include elementwise sine, cosine, and tangent, as well as minimum,
  maximum, and cardinality.  The menu of these operations can include
  a visualization of the operation results next to each operation,
  like Instagram filters.

* Tests can go red and green as your implementation changes;
  implementation code exercised by no green tests can be colored red,
  while implementation code with no test coverage can be colored grey.
  Generative tests can run continuously to produce new test cases, and
  individual test cases can be visualized.

* Quantitative visualizations of input data can be interactively
  edited, changing the data in real time.  This suggests either using
  constraint-solving systems to specify the visualization or using
  iterative optimization algorithms to seek an input to an imperative
  visualization algorithm that will most closely approximate a given
  output.

* Algorithms learned from test data can be applied to further random
  data and the results visualized, or input data collated from other
  sources.

* Tutorials can focus on particular available algebras — integers,
  GF(2³²), strings, and so on — or particular families of algorithms.

