I’ve explored the question of bootstrapping computer systems from
scratch in some detail, but one of the things I haven’t touched on
much is the design of the assembler — that is, the compiler from
assembly language into machine code.  This is somewhat curious,
because assemblers have been quite critical in the bootstrapping
process of actual computers, historically speaking.

History
-------

Early computers were divided into the “first generation” of
vacuum-tube computers (arguably starting with EDVAC and EDSAC in
1949), the “second generation” of transistorized computers (for
example, the popular IBM 7090, first shipped in 1959), and the “third
generation” of integrated-circuit computers (such as the System/360
model 85, 1969).  Similarly, there were three “generations” of
programming languages around the same time — the “first-generation
programming languages” were binary or decimal machine code, the
“second-generation programming languages” were assembly languages
(originating on the EDSAC in 1948, before it actually operated, but
becoming popular around 1955 with SOAP), and the “third-generation
programming languages” were high-level languages like COBOL, ALGOL,
and FORTRAN, arguably starting in 1951 with Grace Hopper’s A-0
compiler or in 1955 with her FLOW-MATIC, but not becoming popular
until the 1960s.

(Many subsequent “generations” have been touted by one or another
person, most famously Moore’s 1970s language FORTH, the fad for
marketing new languages as “4GLs” in the 1990s, and the Japanese Fifth
Generation Computing Project; their implicit promises of revolutionary
improvement have not been fulfilled.)

From their initial popularity in the 1950s until C finally made
assemblers obsolete except for niche tasks around 1988, most computer
systems software (including the assemblers themselves) was written in
assembly language, and during much of this time, even much application
software was written in assembly language.  Among other very
influential software, I believe that all of OS/360, MACLISP, TECO,
BASIC-80, GW-BASIC, AppleSoft BASIC, TOPS-10, TENEX, TOPS-20, MS-DOS,
SNOBOL4, SKETCHPAD, WordStar, VisiCalc, Lotus 1-2-3, QuickDraw, nearly
all NES games, and early versions of Turbo Pascal were all written in
assembly language.  Unix was very unusual in being an operating system
*not* written in assembly starting around 1972 (although the early
versions of Unix were indeed in assembly).

Well into the 1990s, computers were slow enough (and compilers bad
enough) that programming in assembly language was occasionally
necessary for any “serious” programmer — nearly all software ran into
performance bottlenecks that could only be overcome with assembly
language or custom hardware.  So video game engines and
transaction-processing software were routinely written in assembly.
Nowadays, this is much less often the case, and a much smaller
fraction of modern software is written in assembly, particularly since
the bulk of computing power in modern personal computers has shifted
to their Tera-like GPUs — now if you want more computing power, you
reach for the GPU, not assembly language for the CPU.

Knuth (who wrote the software for his landmark book series The Art Of
Computer Programming entirely in assembly language) has suggested that
it’s reasonable to write an assembler in an afternoon, for a computer
that’s not overly complicated, anyway.  Modern binary executable
formats add a certain amount of overhead to this, as do modern
complicated addressing modes.

Stacks and expressions
----------------------

A major weakness of assembly languages is that they don’t have
expressions, except for expressions evaluated at compile-time.  In
effect, you must name all your temporary variables.  Consider these
two lines of C from dietlibc’s `getenv` function:

        if ((memcmp(environ[i],s,len)==0) && (environ[i][len] == '='))
          return environ[i] + len + 1;

If you compile this for i386 in the usual way dietlibc is compiled,
you get this:

      12:lib/getenv.c  ****     if ((memcmp(environ[i],s,len)==0) && (environ[i][len] == '='))
      55              	 .loc 1 12 0
      56 002b 896C2408 	 movl %ebp,8(%esp)
      57 002f 89742404 	 movl %esi,4(%esp)
      58 0033 891C24   	 movl %ebx,(%esp)
      59 0036 E8FCFFFF 	 call memcmp
      59      FF
      60              	.LVL4:
      61 003b 85C0     	 testl %eax,%eax
      62 003d 750C     	 jne .L4
      63              	 .loc 1 12 0 is_stmt 0 discriminator 1
      64 003f 803C2B3D 	 cmpb $61,(%ebx,%ebp)
      65 0043 7506     	 jne .L4
      13:lib/getenv.c  ****       return environ[i] + len + 1;
      66              	 .loc 1 13 0 is_stmt 1
      67 0045 8D442B01 	 leal 1(%ebx,%ebp),%eax
      68 0049 EB0B     	 jmp .L2

(Except that dietlibc has a native assembly version of this function anyway.)


Macros
------

Serious assembly programming makes use of assemb